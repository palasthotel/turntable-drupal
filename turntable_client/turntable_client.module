<?php
// FIXME
ini_set('display_errors', TRUE);

require_once './sites/all/libraries/turntable/turntable_client.php';
require_once './sites/all/libraries/turntable/core/http.php';
require_once './sites/all/libraries/turntable/drupal/util.php';

/**
 * Inject menu.
 *
 * @return array
 */
function turntable_client_menu() {
  $items['admin/config/turntable-client'] = array(
    'title' => t('Turntable Client'),
    'description' => t(
        'Synchronize content between various Drupal installations'),
    'position' => 'right',
    'weight' => -5,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array(
      'administer site configuration'
    ),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system')
  );

  $items['admin/config/turntable-client/settings'] = array(
    'title' => t('Turntable Client Settings'),
    'description' => t('Change how Turntable Client behaves.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'turntable_client_admin_settings'
    ),
    'access arguments' => array(
      'administer site configuration'
    ),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'turntable_client.settings.php'
  );

  $items['node/%/turntable'] = array(
    'title' => t('Turntable'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'turntable_client_shared_state_settings'
    ),
    'access arguments' => array(
      'administer content'
    ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'turntable_client.module'
  );

  // search form
  $items['admin/content/turntable-search'] = array(
    'title' => t('Turntable Search'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'turntable_client_content_search'
    ),
    'access arguments' => array(
      'administer content'
    ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'turntable_client.search.php'
  );

  return $items;
}

/**
 * Delete shared node settings when the corresponding local node is deleted.
 *
 * @param node $node
 */
function turntable_client_node_delete($node) {
  $db = turntable_client::getInstance()->getDB();

  $db->deleteSharedNode($node->nid);
}

/**
 * Enable turntable paths
 *
 * @param array $paths
 */
function turntable_client_admin_paths_alter(&$paths) {
  $paths['node/*/turntable'] = TRUE;
  $paths['admin/content/turntable-search'] = TRUE;
}

/**
 * Returns the ID of the node.
 *
 * @return number id of the node
 */
function get_node_id() {
  if (!is_numeric(arg(1))) {
    return -1;
  }

  // return the node's id
  return (int) arg(1);
}

/**
 * Shared state settings.
 *
 * @return array form
 */
function turntable_client_shared_state_settings() {
  $nid = get_node_id();

  // get the sharing state of the node
  $shared_state = turntable_client::getInstance()->getDB()->getSharedState($nid);

  if ($shared_state == turntable_client::SHARED_COPY ||
       $shared_state == turntable_client::SHARED_REF) {
    $form['turntable_client_shared_states'] = array(
      '#type' => 'value',
      '#value' => array(
        turntable_client::SHARED_COPY => t('Copy'),
        turntable_client::SHARED_REF => t('Reference')
      )
    );

    $form['turntable_client_shared_state'] = array(
      '#type' => 'select',
      '#title' => t('Shared state'),
      '#description' => t(
          'Determines if the local node is a copy of a node on the master or a reference that gets updated on remote changes (local changes will be overwritten)'),
      '#options' => $form['turntable_client_shared_states']['#value'],
      '#default_value' => $shared_state
    );
  } else {
    // determine if the node is shared
    $is_shared = $shared_state == turntable_client::SHARED_ORIG;

    $form['turntable_client_shared_state'] = array(
      '#type' => 'checkbox',
      '#title' => t('Share this node'),
      '#description' => t(
          'Determines if the local node is being shared with the master.'),
      '#default_value' => $is_shared
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save')
  );

  return $form;
}

/**
 * Handles the submission of sharing settings.
 *
 * @param array $form
 * @param array $form_state
 */
function turntable_client_shared_state_settings_submit(&$form, &$form_state) {
  $form_state['rebuild'] = TRUE;

  // get the node's id
  $nid = get_node_id();

  if ($nid == -1) {
    return;
  }

  // get the type of the control element
  $form_type = $form_state['complete form']['turntable_client_shared_state']['#type'];

  // handle checkbox
  if ($form_type == 'checkbox') {
    if ($form_state['values']['turntable_client_shared_state']) {
      $shared_state = turntable_client::SHARED_ORIG;
    } else {
      $shared_state = turntable_client::SHARED_NONE;
    }
  } elseif ($form_state['values']['turntable_client_shared_state']) { // handle dropdown
    $sel = (int) $form_state['values']['turntable_client_shared_state'];
    if ($sel == 0) {
      $shared_state = turntable_client::SHARED_COPY;
    } else {
      $shared_state = turntable_client::SHARED_REF;
    }
  } else {
    drupal_set_message(t('Invalid form.'), 'error');
    return;
  }

  $turntable_client = turntable_client::getInstance();
  // set the shared state
  $turntable_client->getDB()->setSharedState($nid, $shared_state);

  // post to master if it is the original
  if ($shared_state === turntable_client::SHARED_ORIG) {
    $node = node_load($nid);
    send_shared_node($turntable_client, $node);
  }
}

/**
 * Handle the saving of a node
 *
 * @param array $node
 */
function turntable_client_node_presave($node) {
  $turntable_client = turntable_client::getInstance();

  // skip if this node is all new
  if (!isset($node->nid)) {
    return;
  }

  $shared_state = $turntable_client->getDB()->getSharedState($node->nid);

  if ($shared_state === turntable_client::SHARED_ORIG) {
    // if this node is set to SHARED_ORIG
    // send it to the master
    send_shared_node($turntable_client, $node);
  } else if ($shared_state === -1) {
    // if the node's shared state has not yet been set
    $default_shared_node_types = variable_get(
        'turntable_client_share_node_types',
        array(
          'article',
          'page'
        ));

    if (in_array($node->type, $default_shared_node_types)) {
      // if its type is among the node types that are shared by default,
      // set its state to SHARED_ORIG
      $turntable_client->getDB()->setSharedState($node->nid,
          turntable_client::SHARED_ORIG);
      // and send it to the master
      send_shared_node($turntable_client, $node);
    } else {
      // otherwise set its state to SHARED_NONE
      $turntable_client->getDB()->setSharedState($node->nid,
          turntable_client::SHARED_NONE);
    }
  }
}

/**
 * Send a shared node to the master.
 *
 * @param array $turntable_client
 * @param array $node
 * @return boolean
 */
function send_shared_node($turntable_client, $node) {
  global $base_url;
  global $user;

  // prevent sharing of unpublished nodes
  if ($node->status != 1) {
    return;
  }

  $turntable_client = turntable_client::getInstance();
  $turntable_client->setMasterURL(variable_get('turntable_client_master_url'));
  $turntable_client->setClientID(variable_get('turntable_client_id', $base_url));

  $shared_node = array();

  // set properties of $all
  $all = new stdClass();
  foreach ($node as $key => $value) {
    // ignore some properties
    if ($key !== 'original' && substr($key, 0, strlen('field_')) !== 'field_' &&
         substr($key, 0, strlen('group_')) !== 'group_' &&
         substr($key, 0, strlen('form_')) !== 'form_' && $key !== 'rdf_mapping') {
      $all->$key = $value;
    } else if ($key === 'field_image') {
      $all->$key = $value;
    }
  }

  // create an array of all referenced images with the fid on the client and the
  // full url of the image
  $images = array();
  $ewrapper = entity_metadata_wrapper('node', $node);
  if (isset($ewrapper->field_image)) {
    foreach ($ewrapper->field_image->getIterator() as $i => $image) {
      try { // catch exceptions (temporary workaround)
        if ($image && is_object($image->value()) && $image->value()->uri != NULL) {
          $fid = $image->value()->fid;
          $uri = $image->value()->uri;
          $images[] = array(
            'fid' => $fid,
            'uri' => file_create_url($uri)
          );
        }
      } catch (Exception $e) {
      }
    }
  }

  // set data
  $shared_node['title'] = $node->title;
  $shared_node['language'] = $node->language;
  $shared_node['all'] = json_encode($all); // full content

  // set metadata
  $shared_node['node_id'] = $node->nid;
  $shared_node['revision_uid'] = $node->revision_uid;
  $shared_node['content_type'] = $node->type;

  if (isset($user->name)) {
    $shared_node['user_name'] = $user->name;
  } else {
    $shared_node['user_name'] = 'cron';
  }

  $shared_node['author_name'] = $node->name;
  $shared_node['images'] = json_encode($images);
  $shared_node['last_sync'] = date('c');

  $response = $turntable_client->sendSharedNode($shared_node);

  // show errors
  if (!$response) {
    drupal_set_message(t('Turntable Master could not process the request.'),
        'warning');
    return FALSE;
  } else {
    $decoded = json_decode($response);
    if (!$decoded[0]) {
      drupal_set_message(t('Turntable Master did not accept the request.'),
          'warning');
      return FALSE;
    }
  }

  $turntable_client->getDB()->setSharedLastSync($node->nid, time());
  drupal_set_message(t('Shared the node with Turntable Master.'));
  return TRUE;
}

/**
 * Client cron job.
 */
function turntable_client_cron() {
  global $base_url;

  // get db connection etc.
  $turntable_client = turntable_client::getInstance();
  $turntable_client->setMasterURL(variable_get('turntable_client_master_url'));
  $turntable_client->setClientID(variable_get('turntable_client_id', $base_url));
  $db = $turntable_client->getDB();

  $limit = 100;

  // fetch all nodes
  $result = db_select('node', 'n')->fields('n',
      array(
        'nid',
        'type'
      ))->execute();
  $default_shared_state = turntable_client::SHARED_ORIG;

  $default_shared_node_types = variable_get('turntable_client_share_node_types',
      array(
        'article',
        'page'
      ));

  $shared_node_types = array();
  foreach ($default_shared_node_types as $key => $value) {
    if (is_string($value)) {
      $shared_node_types[] = $value;
    }
  }

  // iterate over nodes
  while ($record = $result->fetchAssoc()) {
    $nid = $record['nid'];
    // if the node type is shared by default
    if (in_array($record['type'], $shared_node_types)) {
      // set shared state if it hasn't been set yet
      if ($db->getSharedState($nid) === -1) {
        $db->setSharedState($nid, $default_shared_state);
      }
    }
  }

  foreach ($db->getRemainingSharedNodes($limit) as $nid) {
    // send remaining shared nodes to master
    $node = node_load($nid);
    send_shared_node($turntable_client, $node);
  }

  // update shared nodes
  foreach ($db->getSharedStates() as $shared) {
    if ($shared['shared_state'] === turntable_client::SHARED_REF) {
      update_ref($turntable_client, $db, $shared);
    }
  }
}

/**
 * Updates the local referenced node.
 *
 * @param turntable_client $turntable_client
 * @param turntable_db $db
 * @param array $shared
 */
function update_ref($turntable_client, $db, $shared) {
  $shared_node = $turntable_client->getSharedNode($shared['master_node_id']);

  $local_time = strtotime($shared['last_sync']);
  $remote_time = DateTime::createFromFormat(DateTime::ISO8601,
      $shared_node->last_sync)->getTimestamp();

  // if the remote time is not less than the local time, stop
  if ($remote_time <= $local_time) {
    return;
  }

  // update last sync (locally)
  $db->setSharedLastSync($shared['nid'], $remote_time);

  // decode the node
  $values = std_to_array(json_decode($shared_node->all));

  // check if the content type is available
  if (!in_array($values['type'], get_available_node_content_types())) {
    drupal_set_message(
        t(
            'The selected node could not be imported due to incompatible content type.'),
        'warning');
    return;
  }

  $images = std_to_array(json_decode($shared_node->images));

  $old_node = node_load($shared['nid']);

  // use settings from old node
  $values['uid'] = $old_node->uid;
  $values['status'] = $old_node->status;
  $values['comment'] = $old_node->comment;
  $values['promote'] = $old_node->promote;

  foreach ($images as $i => &$img) {
    // download the image
    $downloaded = download_image($img);

    if ($downloaded) {
      // replace the remote fid with the local fid
      foreach ($values['field_image'] as $lang => &$img_array) {
        foreach ($img_array as $i => &$node_img) {
          if ($node_img['fid'] === $img['fid']) {
            $node_img['fid'] = $img['local_fid'];
          }
        }
      }
    } else {
      drupal_set_message(t('Could not download an image.'), 'warning');
      return;
    }
  }

  // remove unneeded attributes
  unset($values['vid']);
  unset($values['path']);

  // set nid
  $values['nid'] = $shared['nid'];
  $local_node = entity_create('node', $values);

  // save node
  if (entity_save('node', $local_node) === FALSE) {
    drupal_set_message(t('Could not import the selected node.'), 'warning');
    return;
  }
}

/**
 * Converts a stdClass object to an assoc array.
 *
 * @param stdClass $obj
 * @return array
 */
function std_to_array($obj) {
  $reaged = (array) $obj;
  foreach ($reaged as $key => &$field) {
    if (is_object($field) || is_array($field))
      $field = std_to_array($field);
  }
  return $reaged;
}

function download_image(&$img) {
  $dir = 'public://field/image/';
  $fname = url_to_filename($img['uri']);

  $turntable_client = turntable_client::getInstance();
  $url = $turntable_client->getImageURL($img['uri']);

  $info = ensure_image_is_available($dir, $fname, $url);

  if (isset($info['fid'])) {
    $img['local_fid'] = $info['fid'];
    return TRUE;
  } else {
    return FALSE;
  }
}

